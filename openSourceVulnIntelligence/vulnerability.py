"""
Vulnerability class for representing CVE vulnerability data.
"""
import json
from typing import Dict, List, Optional, Any
from datetime import datetime


class Vulnerability:
    """
    Represents a vulnerability with data from multiple sources.
    
    Attributes:
        cve_id: CVE identifier (e.g., CVE-2024-1234)
        cwe: Common Weakness Enumeration description
        cvss: CVSS base score (0-10)
        epss: Exploitation Prediction Scoring System score
        lifecycle: Exploitation status (Exploitation Unknown, Disclosure, Exploitation available, Added to CISA KEV)
        date_published: Publication date
        description: Vulnerability description
        affected: Dictionary of affected vendors and products
        urls: List of reference URLs
        exploit: List of exploit/PoC URLs
    """
    
    def __init__(self, cve_id: str):
        """
        Initialize a Vulnerability object.
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2024-1234)
        """
        self.cve_id = cve_id.upper()
        self.cwe: Optional[str] = None
        self.cvss: Optional[float] = None
        self.epss: Optional[float] = None
        self.lifecycle: Optional[str] = None
        self.date_published: Optional[str] = None
        self.description: Optional[str] = None
        self.affected: Optional[Dict[str, List[Dict]]] = None
        self.urls: Optional[List[str]] = None
        self.exploit: Optional[List[str]] = None
        self._sources: List[str] = []  # Track which sources provided data
        self.priority_score: Optional[float] = None

    def merge_data(self, data: Dict[str, Any], source: str = "unknown") -> None:
        """
        Merge vulnerability data from a scraper.
        
        Uses smart merging logic:
        - Prefer non-None values
        - For CVSS/EPSS, prefer higher values
        - For lifecycle, prefer more severe status
        - For lists, merge and deduplicate
        - For affected products, merge by vendor
        
        Args:
            data: Dictionary with vulnerability data
            source: Name of the data source
        """
        if source not in self._sources:
            self._sources.append(source)
        
        # Simple fields - prefer non-None
        if data.get('cwe') is not None:
            self.cwe = data['cwe']
        
        if data.get('description') is not None:
            self.description = data['description']
        
        if data.get('date_published') is not None:
            self.date_published = data['date_published']
        
        # CVSS - prefer higher score
        if data.get('cvss') is not None:
            if self.cvss is None or data['cvss'] > self.cvss:
                self.cvss = data['cvss']
        
        # EPSS - prefer higher score
        if data.get('epss') is not None:
            if self.epss is None or data['epss'] > self.epss:
                self.epss = data['epss']
        
        # Lifecycle - prefer more severe status
        if data.get('lifecycle') is not None:
            self.lifecycle = self._merge_lifecycle(self.lifecycle, data['lifecycle'])
        
        # URLs - merge and deduplicate
        if data.get('urls') is not None:
            if self.urls is None:
                self.urls = []
            for url in data['urls']:
                if url and url not in self.urls:
                    self.urls.append(url)
        
        # Exploits - merge and deduplicate
        if data.get('exploit') is not None:
            if self.exploit is None:
                self.exploit = []
            for exploit in data['exploit']:
                if exploit and exploit not in self.exploit:
                    self.exploit.append(exploit)
        
        # Affected - merge by vendor
        if data.get('affected') is not None and isinstance(data['affected'], dict):
            if self.affected is None:
                self.affected = {}
            for vendor, products in data['affected'].items():
                if vendor not in self.affected:
                    self.affected[vendor] = []
                # Merge products, avoiding duplicates
                for product in products:
                    if product not in self.affected[vendor]:
                        self.affected[vendor].append(product)
    
    def _merge_lifecycle(self, current: Optional[str], new: Optional[str]) -> str:
        """
        Merge lifecycle statuses, preferring more severe.
        
        Severity order: Added to CISA KEV > Exploitation available > Disclosure > Exploitation Unknown
        """
        if current is None:
            return new
        if new is None:
            return current
        
        severity_order = {
            "Added to CISA KEV": 4,
            "Exploitation available": 3,
            "Disclosure": 2,
            "Exploitation Unknown": 1
        }
        
        current_severity = severity_order.get(current, 0)
        new_severity = severity_order.get(new, 0)
        
        return new if new_severity > current_severity else current
    
    def get_vendors(self) -> List[str]:
        """Get list of affected vendors."""
        if self.affected is None:
            return []
        return list(self.affected.keys())
    
    def get_products(self) -> List[str]:
        """Get list of affected products across all vendors."""
        if self.affected is None:
            return []
        products = []
        for vendor_products in self.affected.values():
            for product_info in vendor_products:
                product = product_info.get('product')
                if product and product not in products:
                    products.append(product)
        return products
    
    def calculate_priority_score(self) -> float:
        """
        Calculate a priority/risk score based on available data.
        
        Score components:
        - CVSS (0-10): 40% weight
        - EPSS (0-100): 30% weight
        - Lifecycle: 30% weight
        
        Returns:
            Priority score from 0-10
        """
        score = 0.0
        
        # CVSS component (50%)
        if self.cvss is not None:
            score += (self.cvss / 10.0) * 10 * 7

        # EPSS component (20%)
        if self.epss is not None:
            score += (self.epss / 100.0) * 2.0
        
        # Lifecycle component (30%)
        lifecycle_scores = {
            "Added to CISA KEV": 6.0,
            "Exploitation available": 4.0,
            "Disclosure": 1.0,
            "Exploitation Unknown": 0.0
        }
        if self.lifecycle:
            score += lifecycle_scores.get(self.lifecycle, 0.0)*10
        
        return min(round(score, 2),100)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            'cve_id': self.cve_id,
            'cwe': self.cwe,
            'cvss': self.cvss,
            'epss': self.epss,
            'lifecycle': self.lifecycle,
            'date_published': self.date_published,
            'description': self.description,
            'affected': self.affected,
            'urls': self.urls,
            'exploit': self.exploit,
            'priority_score': self.calculate_priority_score(),
            'sources': self._sources
        }
    
    def to_json(self, indent: int = 4) -> str:
        """Convert vulnerability to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)
    
    def to_csv_row(self) -> List[str]:
        """Convert vulnerability to CSV row."""
        return [
            self.cve_id,
            self.cwe or '',
            str(self.cvss) if self.cvss is not None else '',
            str(self.epss) if self.epss is not None else '',
            self.lifecycle or '',
            self.date_published or '',
            self.description or '',
            ';'.join(self.get_vendors()) if self.affected else '',
            ';'.join(self.get_products()) if self.affected else '',
            str(len(self.exploit)) if self.exploit else '0',
            str(self.calculate_priority_score())
        ]
    
    def to_markdown(self) -> str:
        """Convert vulnerability to Markdown format."""
        lines = [
            f"# {self.cve_id}",
            "",
            f"**Priority Score:** {self.calculate_priority_score()}/10",
            ""
        ]
        
        if self.cvss is not None:
            lines.append(f"**CVSS:** {self.cvss}")
        if self.epss is not None:
            lines.append(f"**EPSS:** {self.epss}%")
        if self.lifecycle:
            lines.append(f"**Lifecycle:** {self.lifecycle}")
        if self.cwe:
            lines.append(f"**CWE:** {self.cwe}")
        if self.date_published:
            lines.append(f"**Published:** {self.date_published}")
        
        lines.append("")
        
        if self.description:
            lines.append("## Description")
            lines.append("")
            lines.append(self.description)
            lines.append("")
        
        if self.affected:
            lines.append("## Affected Products")
            lines.append("")
            for vendor, products in self.affected.items():
                lines.append(f"### {vendor}")
                
                # Deduplicate products by name for display
                seen_products = {}
                for product_info in products:
                    product = product_info.get('product', 'Unknown')
                    if product not in seen_products:
                        seen_products[product] = product_info
                
                # Display deduplicated products
                for product, product_info in seen_products.items():
                    affected_versions = product_info.get('affected_versions', [])
                    fixed_versions = product_info.get('fixed_versions', [])
                    
                    lines.append(f"- **{product}**")
                    if affected_versions:
                        lines.append(f"  - Affected: {', '.join(affected_versions)}")
                    if fixed_versions:
                        lines.append(f"  - Fixed: {', '.join(fixed_versions)}")
                lines.append("")
        
        if self.exploit:
            lines.append("## Exploits/PoCs")
            lines.append("")
            for exploit_url in self.exploit:
                lines.append(f"- {exploit_url}")
            lines.append("")
        
        if self.urls:
            lines.append("## References")
            lines.append("")
            for url in self.urls[:10]:  # Limit to first 10
                lines.append(f"- {url}")
            lines.append("")
        
        return "\n".join(lines)
    
    def display(self) -> str:
        """Display vulnerability in human-readable format."""
        return (f"{self.cve_id} ({self.cvss or 'N/A'}) - {self.cwe or 'Unknown CWE'} [{self.lifecycle or 'Exploitation Unknown'}]\n{self.description or 'No description available'}")
        
    
    def __str__(self) -> str:
        """String representation."""
        return self.display()
    
    def __repr__(self) -> str:
        """Developer representation."""
        return f"Vulnerability(cve_id='{self.cve_id}', cvss={self.cvss}, lifecycle='{self.lifecycle}')"
